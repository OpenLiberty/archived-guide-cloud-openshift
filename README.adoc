//
// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: cloud-openshift
:page-layout: guide-multipane
:page-duration: 30 minutes 
:page-releasedate: 2019-05-29
:page-description: Explore how to deploy microservices to Red Hat OpenShift
:page-tags: ['Kubernetes', 'Docker', 'Cloud'] 
:page-permalink: /guides/{projectid}
:page-related-guides: ['kubernetes-intro', 'kubernetes-microprofile-config', 'kubernetes-microprofile-health', 'istio-intro'] 
:common-includes: ../guides-common/
:source-highlighter: prettify
:page-seo-title: Deploying microservices to Red Hat OpenShift 
:page-seo-description: A tutorial on how to deploy microservices to OpenShift using OpenShift Container Registry (OCR) as a container registry. 
:guide-author: Open Liberty
= Deploying microservices to OpenShift

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website^].

Explore how to deploy microservices to Red Hat OpenShift. 

:kube: Kubernetes
:hashtag: #
:win: WINDOWS
:mac: MAC
:linux: LINUX
:system-api: http://[hostname]:31000/system/properties
:inventory-api: http://[hostname]:32000/inventory/systems

// =================================================================================================
// Introduction
// =================================================================================================

== What you'll learn 

You will learn how to deploy two microservices in Open Liberty containers to an OpenShift cluster.

There are different cloud-based solutions for running your workloads in a {kube} cluster. 
A cloud-based infrastructure enables you to focus on developing your microservices without 
worrying about details that are related to the servers you deploy them to. Using a cloud helps 
you to easily scale and serve your microservices in a high-availability setup.

Kubernetes is an open source container orchestrator that automates many tasks that are involved in deploying, managing, and scaling containerized applications. 
If you would like to learn more about Kubernetes, check out the https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^] guide.

OpenShift is a Kubernetes-based platform with added functionality. It streamlines the DevOps process by providing an intuitive development pipeline, 
as well as provides integration with multiple tools to make the deployment and management of cloud applications easier.
To learn more about the different platforms that Red Hat OpenShift offers, check out their https://docs.openshift.com[official documentation^]. 

The two microservices you will deploy are called `system` and `inventory`. 
The `system` microservice returns the JVM system properties of the running container. 
It also returns the podâ€™s name in the HTTP header, making replicas easy to distinguish 
from each other. The `inventory` microservice adds the properties from the `system` microservice 
to the inventory. This demonstrates how communication can be established between pods 
inside a cluster.

// =================================================================================================
// Prerequisites
// =================================================================================================

== Prerequisites

Before you begin, the following tools need to be installed:

- *Docker:* You need a containerization software for building containers. Kubernetes 
supports various container types, but you will use Docker in this guide. For installation 
instructions, refer to the official https://docs.docker.com/install/[Docker^] documentation.

- *OpenShift account:* To access a {kube} cluster, you must sign up for a Red Hat account, and select the 30-day trial of the
OpenShift Online Pro tier, which includes access to their public cloud platform. To sign up, refer to the 
https://manage.openshift.com/register/plan[official website^]. Keep in mind that the creation time depends on resource availability, 
and may take some time.

- *OpenShift CLI:* You need the OpenShift command-line tool `oc` to interact with your {kube} cluster.
For installation instructions, refer to the official 
https://docs.openshift.com/online/getting_started/beyond_the_basics.html#btb-installing-the-openshift-cli[OpenShift Online^] documentation.

To verify that the OpenShift CLI is installed correctly, run the following command:

[role=command]
```
oc version
```

You should get an output similar to:

[role="no_copy"]
----
oc v3.11.0+0cbc58b
kubernetes v1.11.0+d4cacc0
features: Basic-Auth

Server https://api.us-east-2.online-starter.openshift.com:6443
kubernetes v1.13.4+8560dd6
----


// =================================================================================================
// Getting Started
// =================================================================================================

[role=command]
include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.

// =================================================================================================
// Accessing an OpenShift cluster
// =================================================================================================

== Accessing an OpenShift cluster

Before you can deploy your microservices, you must gain access to a cluster on OpenShift.

Creating a starter tier OpenShift account will automatically grant you access to their multi-tenant, OpenShift cluster. 
Once you have been granted access, you are also given access to their online web console. To login to OpenShift using the CLI, 
navigate to the online web console `> [username] > Copy Login Command > Display Token > Log in with this token`.

The command will look like this:

[role="no_copy"]
----
oc login --token=[your-token] --server=https://api.[region].online-starter.openshift.com:[port]
----

You will need to work on a project, which you can create by simply running the following command:

[role=command]
```
oc new-project [project-name]
```

// =================================================================================================
// Deploying microservices to OpenShift
// =================================================================================================

== Deploying microservices to OpenShift

In this section, you will learn how to deploy two microservices in Open Liberty containers to a {kube}
cluster on OpenShift. You will build and containerize the `system` and `inventory` microservices, 
push them to a container registry, and then deploy them to your {kube} cluster. 

// =================================================================================================
// Building and containerizing the microservices
// =================================================================================================

=== Building and containerizing the microservices

The first step of deploying to {kube} is to build your microservices and containerize them.

The starting Java project, which you can find in the `start` directory, is a multi-module Maven
project. It is made up of the `system` and `inventory` microservices. Each microservice resides in its own directory,
`start/system` and `start/inventory`. Both of these directories contain a Dockerfile, which is necessary
for building the Docker images. If you're unfamiliar with Dockerfiles, check out the
https://openliberty.io/guides/docker.html[Using Docker containers to develop microservices^] guide.

If you're familiar with Maven and Docker, you might be tempted to run a Maven build first and then
use the `.war` file to build a Docker image. The projects are setup such that this process is automated
as a part of a single Maven build. It is created by using the `dockerfile-maven` plug-in. The plug-in automatically
picks up the Dockerfile that is located in the same directory as its POM file and builds a Docker image from it.

****
[system]#*{win}*#

On the Docker Desktop General Setting page, ensure that the option `Expose daemon on 
tcp://localhost:2375 without TLS` is enabled. This configuration is required by the `dockerfile-maven` 
part of the build.

****

Navigate to the `start` directory and run the following command:

[role=command]
```
mvn package
```

The `package` goal automatically starts the `dockerfile-maven:build` goal. It runs during the
`package` phase. This goal builds a Docker image from the Dockerfile that is located in the same directory
as the POM file.

During the build, you see various Docker messages that describe what images are being downloaded and
built. When the build finishes, run the following command to list all local Docker images:

[role=command]
```
docker images
```

Verify that the `system:1.0-SNAPSHOT` and `inventory:1.0-SNAPSHOT` images are listed among them, for example:

[role="no_copy"]
----
REPOSITORY                    TAG
system                        1.0-SNAPSHOT
inventory                     1.0-SNAPSHOT
open-liberty                  latest
----

If you don't see the `system:1.0-SNAPSHOT` and `inventory:1.0-SNAPSHOT` images, then check the Maven
build log for any potential errors.

// =================================================================================================
// Pushing the images to OpenShift's internal registry
// =================================================================================================

=== Pushing the images to OpenShift's internal registry

In order to run the microservices on the cluster, you need to push the microservice images into a container image registry. 
In this guide you will use OpenShift's integrated container image registry called OpenShift Container Registry (OCR). 
Once your images are pushed into the registry, you can use them in the pods you create later in the guide.

First, you must authenticate your Docker client to your OCR. Start by running the login command:

[role=command]
```
oc registry login
```

You can store your Docker credentials in a custom external credentials store, which is more secure than using a Docker configuration file.
If you are using a custom credentials store for securing your registry credentials, or if you are unsure, you will need to use the following command:

****
[system]#*{mac} & {linux}*#

[role=command]
```
docker login -u `oc whoami` -p `oc whoami -t` `oc registry info`
```
****

****
[system]#*{win}*#

Since the Windows Command Prompt doesn't support the command substitution as displayed above for Mac and Linux, you must run the following commands: 
[role=command]
```
oc whoami
oc whoami -t
oc registry info
```

and replace the square brackets in the following `docker login` command with the results:

[role=command]
```
docker login -u [oc whoami] -p [oc whoami -t] [oc registry info]
```
****

The command authenticates you against the internal registry, allowing you to then be able to push and pull images. The registry address will 
be displayed after running the `oc registry login` command, it will be formatted like so:

[role="no_copy"]
----
default-route-openshift-image-registry.apps.[region].online-starter.openshift.com
----

You can also view the registry address by running the following command:

[role=command]
```
oc registry info
```

Ensure that you are logged in to OpenShift as well as the registry, now run the following commands to tag your applications:

****
[system]#*{mac} & {linux}*#
[role=command]
```
docker tag system:1.0-SNAPSHOT `oc registry info`/`oc project -q`/system:1.0-SNAPSHOT
docker tag inventory:1.0-SNAPSHOT `oc registry info`/`oc project -q`/inventory:1.0-SNAPSHOT
```
****

****
[system]#*{win}*#

Since the Windows Command Prompt doesn't support the command substitution as displayed above for Mac and Linux, you must run the following commands: 
[role=command]
```
oc registry info
oc project -q
```

and replace the square brackets in the following `docker tag` commands with the results:

[role=command]
```
docker tag system:1.0-SNAPSHOT [oc registry info]/[oc project -q]/system:1.0-SNAPSHOT
docker tag inventory:1.0-SNAPSHOT [oc registry info]/[oc project -q]/inventory:1.0-SNAPSHOT
```
****

Finally, push your images to the registry:

****
[system]#*{mac} & {linux}*#

[role=command]
```
docker push `oc registry info`/`oc project -q`/system:1.0-SNAPSHOT
docker push `oc registry info`/`oc project -q`/inventory:1.0-SNAPSHOT
```
****

****
[system]#*{win}*#

Since the Windows Command Prompt doesn't support the command substitution as displayed above for Mac and Linux, you must run the following commands: 
[role=command]
```
oc registry info
oc project -q
```

and replace the square brackets in the following `docker push` commands with the results:

[role=command]
```
docker push [oc registry info]/[oc project -q]/system:1.0-SNAPSHOT
docker push [oc registry info]/[oc project -q]/inventory:1.0-SNAPSHOT
```
****

// =================================================================================================
// Deploying the microservices
// =================================================================================================

=== Deploying the microservices

Now that your container images are built, deploy them using a Kubernetes object configuration file.

{kube} objects can be configured in a yaml file that contains a description of all your 
deployments, services, or any other objects that you want to deploy. All objects can 
also be deleted from the cluster by using the same yaml file that you used to deploy them.
The [hotspot]`kubernetes.yaml` object configuration file is provided for you. If you are interested 
in learning more about using and configuring Kubernetes clusters, check out the 
https://openliberty.io/guides/kubernetes-intro.html[Deploying microservices to Kubernetes^]
guide.

kubernetes.yaml
[source, yaml, linenums, role="code_column"]
----
include::finish/kubernetes.yaml[]
----

[role="code_command hotspot", subs="quotes"]
----
#Update the `kubernetes.yaml` file.#
`kubernetes.yaml`
----

[role="edit_command_text"]
The [hotspot=systemImage hotspot=inventoryImage]`image` is the name and tag of the container image that you want 
to use for the container. The image address that is used is the OCR address that you logged in to, simply update the system 
[hotspot=systemImage]`image` and the inventory [hotspot=inventoryImage]`image` fields to include your project name.

Run the following commands to deploy the objects as defined in kubernetes.yaml:
[role='command']
```
oc apply -f kubernetes.yaml
```

You will see an output similar to the following:

[role="no_copy"]
----
deployment.apps/system-deployment created
deployment.apps/inventory-deployment created
service/system-service created
service/inventory-service created
route.route.openshift.io/system-route created
route.route.openshift.io/inventory-route created
----

When the apps are deployed, run the following command to check the status of your pods:
[role='command']
```
oc get pods
```

If all the pods are healthy and running, you see an output similar to the following:
[source, role="no_copy"]
----
NAME                                    READY     STATUS    RESTARTS   AGE
system-deployment-6bd97d9bf6-4ccds      1/1       Running   0          15s
inventory-deployment-645767664f-nbtd9   1/1       Running   0          15s
----

// =================================================================================================
// Making requests to the microservices
// =================================================================================================

== Making requests to the microservices

To access the services and therefore the application, you need to use a route. A route in OpenShift exposes a service at 
a hostname such as `www.your-web-app.com` so external users can access the application. 

kubernetes.yaml
[source, yaml, linenums, role="code_column"]
----
include::finish/kubernetes.yaml[]
----

Both the [hotspot=systemRoute]`system` and [hotspot=inventoryRoute]`inventory` routes were configured in the [hotspot]`kubernetes.yaml` 
file, and both services were exposed when the `oc apply -f kubernetes.yaml` command was run.

Your microservices can now be accessed through the hostnames which you can find by running the following command:

[role='command']
```
oc get routes
```

They can also be found in the web console under `Networking > Routes > Location`. 
The hostnames will be formatted like so `inventory-route-[project-name].apps.[region].online-starter.openshift.com`. Ensure that
you are in your project, not the default, which is shown in the upper-left corner of the web console.

To access your microservices, point your browser to the following URLs, substituting the appropriate hostnames
for the `system` and `inventory` services:

- `http://[system-hostname]/system/properties/`
- `http://[inventory-hostname]/inventory/systems`

In the first URL, you see a result in JSON format with the system properties of the container JVM. The second URL returns an empty list, 
which is expected because no system properties are stored in the inventory yet.

Point your browser to the `http://[inventory-hostname]/inventory/systems/system-service` URL. When you visit this URL, the system
properties that are taken from the `system-service` are automatically stored in the inventory. Go back to `http://[inventory-hostname]/inventory/systems` 
and you should see a new entry.

// =================================================================================================
// Testing the microservices
// =================================================================================================

== Testing the microservices

pom.xml
[source, xml, linenums, role='code_column']
----
include::finish/pom.xml[]
----

A few tests are included for you to test the basic functionality of the microservices. 
If a test failure occurs, then you might have introduced a bug into the code. 
To run the tests, wait for all pods to be in the ready state before you proceed further. 
The default properties that are defined in the [hotspot]`pom.xml` file are:

[cols="15, 100", options="header"]
|===
| *Property*                                            | *Description*
| [hotspot=systemIP]`system.ip`                         | IP or hostname of the {kube} Service `system-service`
| [hotspot=inventoryIP]`inventory.ip`                   | IP or hostname of the {kube} Service `inventory-service`
| [hotspot=systemKubeService]`system.kube.service`      | Name of the {kube} Service wrapping the `system` pods, `system-service` by default.
|===

Use the following command to run the integration tests against your cluster. Substitute 
`[region]` and `[project-name]` with the appropriate values:

[role=command]
```
mvn verify -Ddockerfile.skip=true \
-Dsystem.ip=system-route-[project-name].apps.[region].online-starter.openshift.com  \
-Dinventory.ip=inventory-route-[project-name].apps.[region].online-starter.openshift.com
```

- The `dockerfile.skip` parameter is set to `true` to skip building a new container image.
- The `system.ip` parameter is replaced with the appropriate hostname to access your system microservice.
- The `inventory.ip` parameter is replaced with the appropriate hostname to access your inventory microservice.

If the tests pass, you see an output for each service similar to the following:

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.system.SystemEndpointTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.673 sec - in it.io.openliberty.guides.system.SystemEndpointTest

Results:

Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
----

[source, role="no_copy"]
----
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running it.io.openliberty.guides.inventory.InventoryEndpointTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.222 sec - in it.io.openliberty.guides.inventory.InventoryEndpointTest

Results:

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
----

// =================================================================================================
// Tearing down the environment
// =================================================================================================

== Tearing down the environment

When you no longer need your deployed microservices, you can delete the {kube} deployments, services, and routes 
by running the following command:

[role='command']
```
oc delete -f kubernetes.yaml
```

To delete the pushed images, run the following commands:

[role='command']
```
oc delete imagestream/inventory
oc delete imagestream/system
```

And finally, you can delete the project by running the following command:

[role='command']
```
oc delete project [project-name]
```

// =================================================================================================
// finish
// =================================================================================================

== Great work! You're done!

You have just deployed two microservices running in Open Liberty to OpenShift. You also 
learned how to use `oc` to deploy your microservices on a {kube} cluster.

// Multipane
include::{common-includes}/attribution.adoc[subs="attributes"]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"